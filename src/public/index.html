<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>canvas.run</title>
<style>
body {
  font-family: sans-serif;
  font-size: 100%;
}
#editor {
  position: absolute;
  top: 1px;
  margin-top: -1px;
  right: 0;
  bottom: 50%;
  left: 0;
  border-bottom: 1px solid #888;
}
#output {
  position: absolute;
  top: 50%;
  right: 0;
  bottom: 0;
  left: 0;
}
#output canvas {
  position: absolute;
}
#error {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: 0;
  background: rgba(255, 255, 255, .75);
  padding: 1em;
  z-index: 2;
  display: none;
  overflow: auto;
  font-family: Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace;
  font-size: .75em;
}
#error:after {
  position: absolute;
  font-size: 40em;
  left: 50%;
  margin-left: -20em;
  top: 50%;
  margin-top: -20em;
  text-align: center;
  width: 40em;
  height: 40em;
  line-height: 40em;
  content: '\26a0';
  color: red;
  opacity: 0.25;
}
#error.-visible {
  display: block;
}
</style>
</head>
<body>
<script type="text/default" id="default">// Here, you're writing the contents of a function with the following signature:
// function render(canvas, t)

// Get the context you want from the "canvas" argument
var ctx = canvas.getContext('2d');

// The "t" argument gives you the milliseconds since the animation started
ctx.fillStyle = 'hsl(200, ' + Math.floor((Math.sin(t / 500) + 1) * 50) + '%, 50%)';
ctx.globalAlpha = 0.3;
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.globalAlpha = 1;

// You can store state in "this"
if (isNaN(this.x)) {
  this.x = canvas.width / 2;
  this.y = canvas.height / 5;
  this.vx = 2;
  this.vy = 0;
}

var radius = 10;

ctx.fillStyle = '#fff';
ctx.beginPath();
ctx.arc(this.x, this.y, radius, 0, 2 * Math.PI, false);
ctx.fill();

this.x += this.vx;
this.y += this.vy;

if (this.x < radius || this.x >= canvas.width - radius) {
  this.vx = -this.vx;
  this.x += this.vx;
}

if (this.y < radius || this.y >= canvas.height - radius) {
  this.vy = -this.vy;
  this.y += this.vy;
}

this.vy += 0.2;</script>
<div id="editor"></div>
<div id="output">
  <canvas id="canvas"></canvas>
  <pre id="error"></pre>
</div>

<script src="vendor/lodash/lodash.min.js"></script>
<script src="vendor/ace-builds/src-min-noconflict/ace.js"></script>
<script src="vendor/ace-builds/src-min-noconflict/mode-javascript.js"></script>
<script>
  var editor = ace.edit('editor');
  editor.$blockScrolling = Infinity;

  editor.getSession().setMode("ace/mode/javascript");

  var rendererState = {};
  var renderer = null;

  function compileRenderer() {
    try {
      renderer = new Function('canvas', 't', editor.getValue());
      hideError();
    } catch (err) {
      renderer = null;

      if (err) {
        renderError(err);
      }
    }
  }

  var shortId = window.location.pathname.slice(1);

  Promise.resolve()
    .then(function () {
      if (shortId) {
        return fetch('/api/runs/' + encodeURIComponent(shortId))
          .then(function (response) {
            if (response.ok) {
              return response.json();
            } else {
              switch (response.status) {
              case 404:
                throw new Error('Run not found');
              default:
                throw new Error('Could not fetch run');
              }
            }
          });
      } else {
        return {
          source: document.getElementById('default').innerHTML
        };
      }
    })
    .then(function (run) {
      editor.setValue(run.source);
      compileRenderer();
    })
    .catch(renderError);

  window.save = function () {
    var formData = new FormData();

    if (shortId) {
      formData.set('shortId', shortId);
    }

    formData.set('source', editor.getValue());

    fetch('/api/runs', { method: 'POST', body: formData })
      .then(function (response) {
        if (response.ok) {
          return response.json();
        } else {
          console.error(response.status);
          throw 'Saving failed';
        }
      })
      .then(function (run) {
        history.pushState(run, 'Run ' + run.shortId, '/' + run.shortId);
      });
  };

  window.addEventListener('popstate', function (event) {
    if (event.state) {
      editor.setValue(event.state.source);
    }
  });

  editor.on('change', _.debounce(compileRenderer, 250));

  var canvas = document.getElementById('canvas');
  var error = document.getElementById('error');

  function resizeCanvas() {
    canvas.width = canvas.parentNode.offsetWidth;
    canvas.height = canvas.parentNode.offsetHeight;
  }

  resizeCanvas();

  window.addEventListener('resize', _.debounce(resizeCanvas, 250));

  function renderError(err) {
    error.className = '-visible';
    error.innerHTML = err.stack
      ? err.stack
      : err.message ? err.message : err;
  }

  function hideError() {
    error.className = '';
  }

  function render(t) {
    requestAnimationFrame(render);

    if (renderer) {
      try {
        renderer.call(rendererState, canvas, t);
        hideError();
      } catch (err) {
        renderer = null;

        if (err) {
          renderError(err);
        }
      }
    }
  }

  render();
</script>
</body>
</html>
